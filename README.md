1. Introduction
The exchange of second-hand goods and the organization of student events are common activities within university communities. However, the absence of secure and user-oriented digital platforms to support these activities presents a notable gap. The UniBazaar Lite project addresses this issue by providing a web-based application that allows university students to list and browse second-hand items, as well as view and engage with campus events. The primary objective of the project is to facilitate student interaction and resource sharing in a way that contributes to a more connected and active campus environment. The application is designed with an emphasis on usability and security to ensure a reliable experience for its users.
2. Technologies Used
This project utilizes various technologies and tools to facilitate and accelerate modern web application development processes. The primary technologies chosen for the project and their purposes are summarized below:
● ASP.NET Core: Used as the main framework for the project. It offers a flexible and scalable structure with both MVC Controller and Razor Pages support.
● C#: The primary programming language chosen for all backend coding. Its strong type system and compatibility with the .NET ecosystem enable secure and rapid development.
● In-Memory Repository: An in-memory repository structure was used for fast data management during the development and testing phases. This allowed for testing the basic functionalities of the application without the need for an external database.
● Custom Middleware and Filters: Custom middleware and action filters were developed to monitor user activities and perform specific validation processes.
● Cookie Authentication: ASP.NET Core's Cookie Authentication mechanism was used for user authentication.
● .NET 9.0: The project was developed on the latest .NET version, thereby leveraging the newest features in terms of performance and security.
These technologies have ensured that the project is developed securely and sustainably. Furthermore, the open-source nature and community support allowed for quick solutions to encountered problems.
2
3. Architectural Justification
Our project utilizes a layered architectural pattern, leveraging the capabilities of ASP.NET Core to promote a robust, maintainable, scalable, and testable application. We have adopted a hybrid approach, combining ASP.NET Core MVC for more traditional controller-based interactions and Razor Pages for simpler, page-centric UI flows. This allows us to select the most appropriate paradigm for each application area.
Controllers (Controllers/): Adhering to the Model-View-Controller (MVC) pattern, ItemsController.cs serves as the entry point for HTTP requests related to item management. Controllers are responsible for processing user input, coordinating with the appropriate services to perform business logic, and selecting the correct view to display the response. This separation ensures that request handling logic is distinct from presentation and business logic.
Razor Pages (Pages/): For areas such as authentication (Pages/Auth/) and event management (Pages/Events/), we employ Razor Pages. This framework simplifies UI development by coupling the page's HTML markup (.cshtml) directly with its code-behind model (.cshtml.cs). Razor Pages are particularly well-suited for scenarios where page-focused development streamlines the logic, making it easier to build and maintain user interfaces with direct data binding.
Services (Services/): This layer is the heart of our application's business logic and data access. We define interfaces (e.g., IItemRepository.cs, IEventRepository.cs) to abstract data operations, promoting loose coupling and adherence to the Dependency Inversion Principle. Concrete implementations, such as InMemoryItemRepository.cs and InMemoryEventRepository.cs, handle the actual data persistence. This design choice significantly enhances testability (services can be unit-tested independently by mocking their dependencies) and scalability (allowing us to easily switch to a different data store like a relational database or NoSQL database in the future without altering the Controller or Razor Page logic).
Filters (Filters/): Filters implement cross-cutting concerns that can be applied to actions in controllers or page handlers in Razor Pages. Examples include LogActivityFilter.cs for logging user actions and ValidateItemExistsFilter.cs and ValidateEntityExistsFilter.cs for ensuring the existence of resources before processing a request. This mechanism promotes code reusability and keeps core business logic clean by offloading common tasks.
3
Middleware (Middleware/): Middleware components form a pipeline through which every HTTP request passes. FakeAuthMiddleware.cs, for instance, simulates authentication logic before the request even reaches a controller or Razor Page. Middleware is ideal for global concerns like authentication, logging, and error handling, as it operates at a lower level of abstraction within the request processing pipeline.
Models (Models/): This directory contains our domain entities (e.g., Item.cs, Event.cs, AppUser.cs) and BindingModels/ (e.g., EventFormModel.cs, ItemFormModel.cs) which are used for data transfer between the UI and the application's business logic. Models ensure data consistency and define the structure of information used throughout the application.
Views (Views/ and Razor Pages .cshtml files): These files constitute the presentation layer, responsible for rendering the user interface. They consume data from Models (passed by Controllers or Page Models) and present it to the user. Shared layouts (_Layout.cshtml) and partial views (_ValidationScriptsPartial.cshtml) ensure a consistent look and feel across the application, adhering to the "Don't Repeat Yourself" (DRY) principle.
This layered architecture, supported by ASP.NET Core's built-in dependency injection and routing mechanisms, ensures clear separation of concerns. UI logic resides in Views and Razor Pages, request routing and validation are managed by Controllers, and core business rules and data management are encapsulated within Services. Filters and Middleware provide a powerful, reusable way to inject cross-cutting logic without cluttering the core application components, leading to a highly maintainable and adaptable codebase.
